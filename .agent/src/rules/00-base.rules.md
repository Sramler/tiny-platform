# 00 全局基础规范

## 适用范围

- 适用于：全仓库
- 不适用于：第三方库代码、生成代码（但建议通过格式化保持一致）

## 总体策略

1. **最小化变更原则**：只改与需求相关的文件与逻辑，不做无关重构。
2. **可回滚原则**：所有变更必须可回滚，保持向后兼容或提供迁移方案。
3. **文档驱动原则**：不确定时必须写出假设、风险、默认策略。

---

## 禁止（Must Not）

### 1) 结构与架构

- ❌ 不允许在不明确需求/上下文时直接大改结构或重构。
- ❌ 不允许引入与需求无关的依赖/框架。
- ❌ 不允许破坏现有模块边界（除非有明确收益且经过评审）。
- ❌ 不允许在核心模块中硬编码业务逻辑（应抽象为可配置/可扩展）。

### 2) 代码质量

- ❌ 不允许提交无法验证的代码（必须有测试或明确验证步骤）。
- ❌ 不允许提交包含 TODO/FIXME 的代码（除非有明确的跟踪任务）。
- ❌ 不允许提交包含调试代码（如 `System.out.println`、未使用的 import）。

### 3) 依赖管理

- ❌ 不允许引入有已知安全漏洞的依赖。
- ❌ 不允许引入与现有依赖冲突的版本（必须解决冲突）。

---

## 必须（Must）

### 1) 变更管理

- ✅ 不确定时必须写出：假设、风险、默认策略。
- ✅ 修改最小化：只改与需求相关的文件与逻辑。
- ✅ 变更需可回滚：说明回退方案或保持兼容。
- ✅ 破坏性变更必须提供迁移指南和版本说明。

### 2) 代码审查

- ✅ 关键变更（涉及安全/权限/多租户）必须经过代码审查。
- ✅ 新增依赖必须说明引入原因和使用场景。
- ✅ 重构代码必须说明重构原因和收益。

### 3) 文档与注释

- ✅ 公共 API 必须有文档（Javadoc/TSDoc）。
- ✅ 复杂业务逻辑必须有注释（解释"为什么"而非"是什么"）。
- ✅ 配置项必须有说明（默认值、可选值、影响范围）。

---

## 应该（Should）

### 1) 模块与能力

- ⚠️ 新增模块/公共能力应配套示例与最小文档。
- ⚠️ 关键逻辑需要可读命名与必要注释（解释"为什么"）。
- ⚠️ 模块间依赖应明确且最小化（避免循环依赖）。

### 2) 性能与资源

- ⚠️ 新增功能应考虑性能影响（响应时间、资源消耗）。
- ⚠️ 大数据处理必须分页/流式，避免一次性加载全量数据。

### 3) 测试与验证

- ⚠️ 关键业务逻辑应提供单元测试或集成测试。
- ⚠️ 新增功能应提供验证步骤（手动测试或自动化测试）。

---

## 可以（May）

- 💡 在提交说明中写清：变更点 + 验证方式。
- 💡 使用设计模式提升代码可维护性（但不过度设计）。
- 💡 引入新技术/框架前先做技术验证（POC）。

---

## 例外与裁决

### 紧急修复

- 紧急安全漏洞修复可简化流程，但必须事后补全文档和测试。
- 紧急修复必须明确标注（如提交信息包含 `[URGENT]`）。

### 实验性功能

- 实验性功能可在独立分支开发，不强制遵循所有规范，但合并前必须符合规范。
- 实验性功能必须明确标注（如包名包含 `experimental`、类名包含 `Experimental`）。

### 冲突裁决

- 平台特定规则（90+）优先于本规范。
- 安全规范（40-security）优先于一切。
- 当规则冲突时，必须说明裁决依据。

---

## 示例

### ✅ 正例：明确假设和风险

```java
/**
 * 更新用户信息
 * 
 * 假设：用户已登录，session 有效
 * 风险：并发修改可能导致数据不一致
 * 策略：使用乐观锁 version 字段
 * 
 * @param user 用户信息
 * @throws OptimisticLockingFailureException 并发修改冲突时抛出
 */
public void updateUser(User user) {
    // 实现逻辑
}
```

### ❌ 反例：直接大改结构，没有说明原因

```java
// 错误：直接大改结构，没有注释说明为什么
public void refactor() {
    // 大量重构代码，没有注释说明为什么
}
```

### ✅ 正例：破坏性变更提供迁移指南

```java
/**
 * 用户服务
 * 
 * @deprecated 使用 {@link NewUserService} 替代
 * @see <a href="https://wiki.example.com/migration-guide">迁移指南</a>
 */
@Deprecated
public class UserService {
    // ...
}
```

### ❌ 反例：破坏性变更无说明

```java
// 错误：直接删除方法，没有迁移方案
public class UserService {
    // 删除了 getUserById 方法，导致调用方编译失败
}
```

### ✅ 正例：新增依赖说明原因

```java
// 引入原因：需要支持 JSON Schema 验证
// 使用场景：API 请求参数动态校验
// 版本：1.0.0（稳定版本）
dependencies {
    implementation 'com.github.java-json-tools:json-schema-validator:1.0.0'
}
```

### ❌ 反例：新增依赖无说明

```java
// 错误：引入依赖但没有说明原因
dependencies {
    implementation 'some-library:1.0.0' // 为什么引入？
}
```
